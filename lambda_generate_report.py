#!/usr/bin/env python3
"""
Lambda: RCA Report Generator
Automatically generates Markdown report from Commander output

This runs as the FINAL step in Step Functions
"""

import json
import boto3
import os
from datetime import datetime

s3_client = boto3.client('s3')

REPORTS_BUCKET = os.environ.get('REPORTS_BUCKET', 'hackathon-team14-bucket')

def generate_rca_report(commander_output):
    """Convert Commander JSON output to Markdown RCA report"""
    
    # Extract key information
    root_cause = commander_output.get('root_cause', 'Unknown')
    confidence = commander_output.get('confidence', 0.0)
    remediation_steps = commander_output.get('remediation_steps', [])
    evidence = commander_output.get('evidence', {})
    llm_reasoning = commander_output.get('llm_reasoning', '')
    
    # Generate report
    report = f"""# Incident Root Cause Analysis Report

**Generated:** {datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S UTC')}  
**Status:** Investigation Complete  
**Confidence:** {confidence * 100:.0f}%

---

## üéØ Executive Summary

### Root Cause
{root_cause}

### Confidence Level
{'üü¢ HIGH' if confidence >= 0.85 else 'üü° MEDIUM' if confidence >= 0.7 else 'üî¥ LOW'} ({confidence * 100:.0f}%)

---

## üìä Evidence Analysis

### LogsAgent Findings (WHAT Happened)
"""
    
    logs_analysis = evidence.get('logs', {})
    if logs_analysis:
        what_happened = logs_analysis.get('what_happened', 'No data')
        report += f"\n- **Primary Issue:** {what_happened}\n"
        
        correlation = logs_analysis.get('correlation', {})
        if correlation and correlation.get('correlation_found'):
            report += f"""- **Deployment Correlation:** {correlation.get('percentage', 0):.1f}% of errors linked to deployment `{correlation.get('deployment_id')}`
- **Insight:** {correlation.get('insight', 'N/A')}
"""
        
        error_patterns = logs_analysis.get('error_patterns', [])
        if error_patterns:
            report += "\n**Top Error Patterns:**\n"
            for i, pattern in enumerate(error_patterns[:5], 1):
                error_type = pattern.get('error_type', 'Unknown')
                count = pattern.get('error_count', 0)
                service = pattern.get('service', 'unknown')
                report += f"{i}. `{error_type}` - {count} occurrences ({service})\n"
    
    report += "\n### MetricsAgent Findings (HOW BAD)\n"
    
    metrics_analysis = evidence.get('metrics', {})
    if metrics_analysis:
        severity = metrics_analysis.get('how_bad', 'UNKNOWN')
        severity_score = metrics_analysis.get('severity_score', 0)
        
        severity_emoji = {
            'CRITICAL': 'üî¥',
            'HIGH': 'üü†',
            'MEDIUM': 'üü°',
            'LOW': 'üü¢'
        }.get(severity, '‚ö™')
        
        report += f"""
- **Severity:** {severity_emoji} {severity} (Score: {severity_score}/100)
- **Recommended Action:** {metrics_analysis.get('recommended_action', 'Monitor')}
"""
        
        error_rate = metrics_analysis.get('error_rate', {})
        if error_rate:
            spike_ratio = error_rate.get('spike_ratio', 1.0)
            report += f"- **Error Rate Spike:** {spike_ratio:.1f}x above baseline\n"
    
    report += "\n### DeployAgent Findings (FIX Options)\n"
    
    deploy_analysis = evidence.get('deploy', {})
    if deploy_analysis:
        fix_recommendation = deploy_analysis.get('fix_recommendation', {})
        
        if fix_recommendation.get('recommend_rollback'):
            report += f"""
- **Recommendation:** ‚úÖ ROLLBACK RECOMMENDED
- **Target Deployment:** `{fix_recommendation.get('deployment_id')}`
- **Reason:** {fix_recommendation.get('reason')}
"""
        else:
            report += f"\n- **Recommendation:** ‚ùå Rollback not recommended\n"
    
    report += "\n---\n\n## üß† LLM Reasoning\n\n"
    report += f"{llm_reasoning}\n" if llm_reasoning else "*LLM reasoning not available*\n"
    
    report += "\n---\n\n## üîß Remediation Steps\n\n"
    
    if remediation_steps:
        for i, step in enumerate(remediation_steps, 1):
            report += f"{i}. {step}\n"
    else:
        report += "*No specific remediation steps provided*\n"
    
    report += f"""
---

## üìù Next Actions

### Immediate
1. Review this RCA with the team
2. {'Proceed with rollback if approved' if deploy_analysis.get('fix_recommendation', {}).get('recommend_rollback') else 'Monitor the situation'}
3. Notify stakeholders

---

**Report Generated by:** Autonomous Incident Commander  
**LLM Model:** Claude 3.5 Sonnet (Amazon Bedrock)  
**Agent Framework:** Multi-Agent AWS Step Functions
"""
    
    return report


def lambda_handler(event, context):
    """
    Input: Commander output (final Step Functions state)
    Output: S3 URL to generated report
    """
    
    print("üìù Generating RCA Report...")
    
    # Generate report
    report_markdown = generate_rca_report(event)
    
    # Create filename with timestamp
    timestamp = datetime.utcnow().strftime('%Y%m%d_%H%M%S')
    incident_id = context.request_id[:8]
    filename = f"rca_reports/incident_{incident_id}_{timestamp}.md"
    
    # Upload to S3
    s3_client.put_object(
        Bucket=REPORTS_BUCKET,
        Key=filename,
        Body=report_markdown,
        ContentType='text/markdown',
        Metadata={
            'incident_id': incident_id,
            'confidence': str(event.get('confidence', 0)),
            'generated_at': datetime.utcnow().isoformat()
        }
    )
    
    s3_url = f"https://{REPORTS_BUCKET}.s3.amazonaws.com/{filename}"
    
    print(f"‚úÖ Report saved to: s3://{REPORTS_BUCKET}/{filename}")
    
    # Return everything from Commander + report URL
    return {
        **event,  # Include all Commander output
        'report_url': s3_url,
        'report_s3_path': f"s3://{REPORTS_BUCKET}/{filename}",
        'report_generated_at': datetime.utcnow().isoformat()
    }


# For local testing
if __name__ == '__main__':
    test_event = {
        'agent': 'CommanderAgent',
        'root_cause': 'ConnectionPoolExhaustedException due to config v40',
        'confidence': 0.92,
        'remediation_steps': [
            'Rollback deployment',
            'Increase connection pool size'
        ],
        'evidence': {
            'logs': {
                'what_happened': 'ConnectionPool errors',
                'correlation': {
                    'deployment_id': 'deploy_1009',
                    'percentage': 68.5,
                    'correlation_found': True
                }
            },
            'metrics': {
                'how_bad': 'CRITICAL',
                'severity_score': 85
            },
            'deploy': {
                'fix_recommendation': {
                    'recommend_rollback': True,
                    'deployment_id': 'deploy_1009'
                }
            }
        },
        'llm_reasoning': 'Test reasoning'
    }
    
    class Context:
        request_id = 'test-123'
    
    result = lambda_handler(test_event, Context())
    print(json.dumps(result, indent=2))
